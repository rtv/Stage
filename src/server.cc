/*
 *  Stage : a multi-robot simulator.
 *  Copyright (C) 2001, 2002 Richard Vaughan, Andrew Howard and Brian Gerkey.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */
/*
 * Desc: This class implements the server, or main, instance of Stage.
 * Author: Richard Vaughan, Andrew Howard
 * Date: 6 Jun 2002
 * CVS info: $Id: server.cc,v 1.44.4.2 2003-02-01 02:14:30 rtv Exp $
 */
#if HAVE_CONFIG_H
  #include <config.h>
#endif
#if HAVE_STRINGS_H
  #include <strings.h>
#endif

#include <arpa/inet.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <math.h>
#include <netdb.h>
#include <netinet/in.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <termios.h>
#include <unistd.h>

#include "stageio.h"
#include "server.h"

// prototype for the library's C wrapper
#include "entity.hh"
CEntity* CreateEntityFromLibrary( char* token, int id, CEntity* parent_ptr );

typedef	struct sockaddr SA; // useful abbreviation
 
#define DEBUG
//#define VERBOSE

int listen_port =  STG_DEFAULT_SERVER_PORT;

// the master-server's listening socket
struct pollfd listen_poll;

// the current connection details
struct pollfd connection_polls[ STG_MAX_CONNECTIONS ];
int connection_count;

//char* hostname = "localhost";

// dummy timer signal func
void TimerHandler( int val )
{
#ifdef VERBOSE
  PRINT_DEBUG( "TIMER HANDLER" );
#endif

  //g_timer_events++;

  // re-install signal handler for timing
  assert( signal( SIGALRM, &TimerHandler ) != SIG_ERR );

  PRINT_DEBUG( "timer expired" );
}  

void CatchSigPipe( int signo )
{
#ifdef VERBOSE
  puts( "** SIGPIPE! **" );
#endif
  exit( -1 );
}


int InitServer( int argc, char** argv )
{ 
  PRINT_DEBUG( "Start" );
  
  PRINT_DEBUG( "Resolving hostname" );

  //////////////////////////////////////////////////////////////////////
  // FIGURE OUT THE DEFAULT FULL HOST NAME & ADDRESS
  
  // maintain a connection to the nameserver - speeds up lookups
  sethostent( TRUE );
  
  PRINT_DEBUG( "Getting host information for localhost" );
  struct hostent* info = gethostbyname( "localhost" );
  assert( info );
  struct in_addr current_hostaddr;
  
  // make sure this looks like a regular internet address
  assert( info->h_length == 4 );
  assert( info->h_addrtype == AF_INET );
  
  // copy the address out
  memcpy( &current_hostaddr.s_addr, info->h_addr_list[0], 4 ); 

  ////////////////////////////////////////////////////////////////////
  PRINT_DEBUG( "Setting up connection server" );

  listen_poll.fd = socket(AF_INET, SOCK_STREAM, 0);
  listen_poll.events = POLLIN; // notify me when a connection request happens
  
  struct sockaddr_in servaddr;  
  bzero(&servaddr, sizeof(servaddr));
  
  servaddr.sin_family      = AF_INET;
  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  servaddr.sin_port        = htons(listen_port);
  
  // switch on the re-use-address option
  const char on = 1;
  setsockopt( listen_poll.fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on) );
  
  if( bind(listen_poll.fd, (SA *) &servaddr, sizeof(servaddr) )  < 0 )
  {
    perror("failed bind");

    printf( "Port %d is in use. Quitting (but try again in a few seconds).", 
	    listen_port );
    return -1; // fail
  }
  
  // catch signals generated by socket closures
  signal( SIGPIPE, CatchSigPipe );
  
  // listen for requests on this socket
  // we poll it in ListenForPoseConnections()
  assert( listen( listen_poll.fd, STG_LISTENQ) == 0 );


  PRINT_DEBUG( "End" );

  return 0; //success
}


int ParseCmdLine( int argc, char** argv )
{
  int a;
  
  for( a=1; a<argc-1; a++ )
    {
      /*      // FAST MODE - run as fast as possible - don't attempt t match real time */
      /*      if((strcmp( argv[a], "--fast" ) == 0 ) ||  */
      /*         (strcmp( argv[a], "-f" ) == 0)) */
      /*      { */
      /*        m_real_timestep = 0.0; */
      /*        printf( "[Fast]" ); */
      /*      } */
      
      /*      // set the stop time */
      /*      if(!strcmp(argv[a], "-t")) */
      /*        { */
      /*  	m_stoptime = atoi(argv[++a]); */
      /*  	printf("[Stop time: %d]",m_stoptime); */
      /*        } */
      
      /*      // START WITH CLOCK STOPPED */
      /*      if( strcmp( argv[a], "-s" ) == 0 ) */
      /*        { */
      /*  	this->start_disabled = true; */
      /*  	printf( "[Clock stopped (start with SIGUSR1)]" ); */
      /*        } */
    }
  
  return 0; // success
}

int AcceptConnections( void )
{
  int readable = 0;
  int retval = 0; // 0: success, -1: failure
  
  // poll for connection requests with a very fast timeout
  if((readable = poll( &listen_poll, 1, 0 )) == -1)
    {
      if( errno != EINTR ) // timer interrupts are OK
	{ 
	  perror( "Stage warning: poll error (not EINTR)");
	  return -1; // fail
	}
    }
  
  // if the socket had a request
  if( readable && (listen_poll.revents & POLLIN ) ) 
    {
      // set up a socket for this connection
      struct sockaddr_in cliaddr;  
      bzero(&cliaddr, sizeof(cliaddr));
#if PLAYER_SOLARIS
      int clilen;
#else
      socklen_t clilen;
#endif
      
      clilen  = sizeof(cliaddr);
      int connfd = 0;
      
      connfd = accept( listen_poll.fd, (SA *) &cliaddr, &clilen);
      
      
      // set the dirty flag for all entities on this connection
      //DirtyEntities( m_pose_connection_count );
      
      
      // determine the type of connection, sync or async, by reading
      // the first byte
      char b = 0;
      int r = 0;
      
      if( (r = read( connfd, &b, 1 )) < 1 ) 
	{
	  puts( "failed to read sync type byte. Quitting\n" );
	  if( r < 0 ) perror( "read error" );
	  return -1; // fail
	}
      
      // if this is a syncronized connection, increase the sync counter 
      switch( b )
	{
	case STAGE_SYNC: 
#ifdef VERBOSE      
	  printf( "\nStage: connection accepted (id: %d fd: %d)\n", 
		  connection_count, connfd );
	  fflush( stdout );
#endif            
	  retval = 0; //success
	  break;
	  
	default: printf( "Stage: unknown sync on %d. Closing connection\n",
			 connfd  );
	  close( connfd );
	  retval = -1; // fail
	  break;
	}
      
   
      if( retval != -1 ) // if successful
	{
	  connection_polls[ connection_count ].fd = connfd;
	  connection_polls[ connection_count ].events = POLLIN;
	  connection_count++;
	}
    }

  return retval;
}

void DestroyConnection( int con )
{

  PRINT_DEBUG1( "Closing connection %d", con );

  close( connection_polls[con].fd );
  
  connection_count--;
  
  // shift the rest of the array 1 place left
  int p;
  for( p=con; p<connection_count; p++ )
    {
      // the pollfd array
      memcpy( &(connection_polls[p]), 
	      &(connection_polls[p+1]),
	      sizeof( struct pollfd ) );
    }      
  
  PRINT_DEBUG1( "remaining connections %d", connection_count );
}


int HandleModel( int fd, int num )
{
  size_t bytes_expected = num * sizeof(stage_model_t);
  stage_model_t* models =  (stage_model_t*)malloc(bytes_expected);
  
  size_t bytes_read;
  if( (bytes_read = ReadModels( fd, models, num )) != bytes_expected )
    {
      free( models );
      return -1; // fail
    }
  
  // create models
  
  int m;
  for( m=0; m<num; m++ )
  {
    printf( "Creating model %d %s parent %d\n",
	    models[m].id, models[m].token, models[m].parent );

    CreateEntityFromLibrary( models[m].token, models[m].id, NULL );

  }
  return 0;
}

int ServiceConnections( void )
{
  // read stuff until we get a continue message on each channel
#ifdef VERBOSE
  PRINT_DEBUG( "Start" );
#endif    

  // we want poll to block until it is interrupted by a timer signal,
  // so we give it a time-out of -1.
  int timeout = -1;
  int readable = 0;
  int syncs = 0;  
  
  // we loop on a poll until have a sync from all clients or we run
  // out of connections
  while( (syncs < connection_count) ||  (connection_count > 0) ) 
    {
      // use poll to see which pose connections have data
      if((readable = 
	  poll( connection_polls,
		connection_count,
		timeout )) == -1) 
	{
	  PRINT_ERR( "poll(2) returned error)");	  
	  return -1; // fail
	}
      
      if( readable > 0 )
	{
	  int t;
	  for( t=0; t<connection_count; t++ )// all the connections
	    {
	      short revents = connection_polls[t].revents;
	      int confd = connection_polls[t].fd;
	      
	      if( revents & POLLIN )// data available
		{ 
		  //printf( "poll() says data available "
		  //  "(POLLIN) on connection %d\n", t );
		  
		  int hdrbytes;
		  stage_header_t hdr;
		  
		  hdrbytes = ReadHeader( confd, &hdr); 
		  
		  if( hdrbytes < (int)sizeof(hdr) )
		    {
		      //printf( "Failed to read header on connection %d "
		      //      "(%d/%d bytes).\n"
		      //      "Connection closed",
		      //      t, hdrbytes, sizeof(hdr) );
		      
		      DestroyConnection( t ); // zap this connection
		    }
		  else // find out the type of packet to follow
		    {  // and handle it
		      switch( hdr.type )
			{
			case StagePropertyPackets: // some poses are coming in 
			  PRINT_DEBUG2( "INCOMING PROPERTIES (%d) ON %d\n", 
					hdr.data, confd );
			  //ReadProperties( t, confd, hdr.data );
			  break;
			  
			case StageCommand:
			  PRINT_DEBUG2( "INCOMING COMMAND (%d) on %d\n",
					hdr.data, confd );
			  //HandleCommand( t, (stage_cmd_t)hdr.data );
			  break;
			  
			case StageModelPackets:
			  PRINT_DEBUG2( "INCOMING ENTITIES (%d) on %d\n", 
					hdr.data, confd );
			  HandleModel( confd, hdr.data );
			  break;
			  
			case StageContinue: // this marks the end of the data
			  PRINT_DEBUG1( "CONTINUE ON %d\n", confd );
			  
			  syncs++;
			  break;

			default:
			  printf( "Stage warning: unknown mesg type %d"
				  " on connection %d (fd %d)\n",
				  hdr.type, t, confd );
			}
		    }
		}
	      // if poll reported some badness on this fd
	      else if( !revents & EINTR ) //
		{
		  printf( "Stage: connection %d seems bad\n", t );
		  DestroyConnection( t ); // zap this connection
		}    
	    }
	}
    }    
  
#ifdef VERBOSE
  PRINT_DEBUG( "End");
#endif

  return 0;
}
  
  

